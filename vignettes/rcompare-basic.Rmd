---
title: "Introduction to dfcompare"
author: "Craig Gower & Kieran Martin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The purpose of `dfcompare` is to provide `proc compare` like functionality to R for use in second line programming. In particular we focus on raising warnings if any differences are found whilst providing in-depth diagnostics to highlight where these differences have occurred. 


## Basic usage

Here we show the basic functionality of `dfcompare` using a dummy data set.

```{r}
library(dfcompare)

LENGTH = 30
set.seed(12334)
test_data <- tibble::tibble( 
    ID          = 1:LENGTH,
    GROUP1      = rep( c(1,2) , each = LENGTH/2),
    GROUP2      = rep( c(1:(LENGTH/2)), 2 ),
    INTEGER     = rpois(LENGTH , 40),
    BINARY      = sample( c("M" , "F") , LENGTH , replace = T),
    DATE        = lubridate::ymd("2000-01-01") + rnorm(LENGTH, 0, 7000),
    DATETIME    = lubridate::ymd_hms("2000-01-01 00:00:00") + rnorm(LENGTH, 0, 200000000), 
    CONTINUOUS  = rnorm(LENGTH , 30 , 12),
    CATEGORICAL = factor(sample( c("A" , "B" , "C") , LENGTH , replace = T)),
    LOGICAL     = sample( c(TRUE , FALSE) , LENGTH , replace = T),
    CHARACTER   = stringi::stri_rand_strings(LENGTH,  rpois(LENGTH , 13),  pattern = "[ A-Za-z0-9]")
)

test_data

dfcompare( test_data , test_data)
```

As you would expect no differences are found. We now look to introduce various types differences into the data in order to show how `dfcompare` highlights them.  Note that for the purposes of this vignette we have used the `suppress_warnings` argument to stop errors being raised; it is recommended however that this option is not used in production code as it may mask problems. 


### Missing Columns

```{r}
test_data2 <- test_data 
test_data2 <- test_data2[,-6]
dfcompare(test_data , test_data2 , suppress_warnings = T)
```


### Missing Rows 

```{r}
test_data2 <- test_data
test_data2 <- test_data2[1:(nrow(test_data2) - 2),]
dfcompare(test_data, test_data2 , suppress_warnings = T)
```


### Different Values 

```{r}
test_data2 <- test_data
test_data2[5,2] <- 6
dfcompare(test_data , test_data2 , suppress_warnings = T)
```


### Different Types

```{r}
test_data2 <- test_data
test_data2[5,2] <- "blah"
dfcompare(test_data , test_data2 , suppress_warnings = T)
```


### Different Labels

```{r}
test_data2 <- test_data
attr(test_data$ID , "label") <- "This is a interesting label"
attr(test_data2$ID , "label") <- "what do I type here?"
dfcompare(test_data , test_data2 , suppress_warnings = T)
```

### Different Factor Levels 

```{r}
test_data2 <- test_data
levels(test_data2$CATEGORICAL) <- c(1,2,3)
dfcompare(test_data , test_data2 , suppress_warnings = T)
```

## Grouping Variables

A key feature of `dfcompare` that enables easier diagnostics is the ability to specify which variables form a unique row i.e. which rows should be compared against each other based upon a key. By default if no key is specified `dfcompare` will use the rownumber as the key however in general this isn't recommended as it means two identical datasets simply sorted differently can lead to incomprehensible error messages as every observation is flagged as different.  In `dfcompare` keys can be specified as character vectors using the `keys` argument.

```{r}
test_data2 <- test_data
test_data2$INTEGER[c(5,2,15)] <- 99L 
dfcompare( test_data , test_data2 , keys = c("GROUP1" , "GROUP2") , suppress_warnings = T)
```

## Printing and Saving the Compare Log

When there are lots of mismatches the log can become unwieldly. In order to deal with this you can either use the `print` function to display a particular variable or the `outfile` option to save the log to a file. 


```{r, eval=FALSE}
result <- dfcompare( 
    test_data , 
    test_data2 , 
    keys = c("GROUP1" , "GROUP2") , 
    outfile =  "reports/dfcompare.log"
)

```

## Misc


### Tolerance

You can use the `tolerance` argument of `dfcompare` to define how sensitive the comparison should be to decimal place inaccuracies. This important as very often floating point numbers will not compare equal due to machine rounding as they cannot be perfectly represented in binary. By default tolerance is set to `sqrt(.Machine$double.eps)`

```{r}
dsin1 <- data.frame(x = 1.1e-06)
dsin2 <- data.frame(x = 1.1e-07)

dfcompare(dsin1  , dsin2 , suppress_warnings = T)

dfcompare(dsin1  , dsin2 , tolerance = 0.001 , suppress_warnings = T)
```








